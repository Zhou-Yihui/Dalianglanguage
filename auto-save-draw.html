<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>é›…è¨€å­—ç¬¦é€ å­—</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body { background:#0b0c2a; color:#fff; font-family:"Microsoft YaHei"; text-align:center; margin:0; padding:20px; }
  canvas { background:#111; border:1px solid #f0c000; border-radius:6px; margin-top:10px; }
  select, button { margin:8px; padding:8px 16px; border:none; border-radius:6px; cursor:pointer; font-size:15px; }
  button:hover { opacity:0.9; }
  #renderBtn { background:#f0c000; color:#000; }
</style>
</head>
<body>
<h2>ğŸŒŒ é›…è¨€å­—ç¬¦é€ å­—</h2>
<select id="charSelect"></select>
<input type="text" id="charName" placeholder="è¾“å…¥å­—ç¬¦åç§°ï¼ˆæ‹‰ä¸éŸ³åç­‰ï¼‰">
<button id="addBtn">æ·»åŠ æ–°å­—ç¬¦</button>
<button id="renderBtn">æ¸²æŸ“å­—ç¬¦</button>
<canvas id="canvas" width="300" height="300"></canvas>
<br>
<input type="file" id="importFile">
<button id="exportBtn">å¯¼å‡ºåˆ°æœ¬åœ°</button>
<button id="uploadBtn">ä¸Šä¼ åˆ° GitHub</button>

<script>
// ===== åˆå§‹åŒ–æ•°æ®ï¼Œä¿ç•™å·²æœ‰æ•°æ® =====
let allChars = JSON.parse(localStorage.getItem("stargate_chars"));
if(!allChars) allChars = { chars: [] };

// ===== æ¸²æŸ“å™¨ =====
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function renderChar(strokes, width, height){
  if(!strokes || strokes.length===0){
    ctx.clearRect(0,0,width,height);
    return;
  }
  let xs=[], ys=[];
  strokes.forEach(stroke=>stroke.forEach(p=>{ xs.push(p.x); ys.push(p.y); }));
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const charWidth=maxX-minX, charHeight=maxY-minY;
  const scale=Math.min(width/charWidth, height/charHeight)*0.8;
  const offsetX=(width-charWidth*scale)/2-minX*scale;
  const offsetY=(height-charHeight*scale)/2-minY*scale;
  ctx.clearRect(0,0,width,height);
  ctx.strokeStyle="#f0c000";
  ctx.lineWidth=2;
  ctx.lineJoin="round";
  ctx.lineCap="round";
  strokes.forEach(stroke=>{
    if(stroke.length===0) return;
    ctx.beginPath();
    ctx.moveTo(stroke[0].x*scale+offsetX, stroke[0].y*scale+offsetY);
    for(let i=1;i<stroke.length;i++){
      const prev=stroke[i-1], curr=stroke[i];
      const midX=(prev.x+curr.x)/2, midY=(prev.y+curr.y)/2;
      ctx.quadraticCurveTo(prev.x*scale+offsetX, prev.y*scale+offsetY, midX*scale+offsetX, midY*scale+offsetY);
    }
    ctx.stroke();
  });
}

// ===== ä¸‹æ‹‰æ›´æ–° =====
const charSelect=document.getElementById("charSelect");
function updateCharSelect(){
  charSelect.innerHTML="";
  allChars.chars.forEach(c=>{
    const opt=document.createElement("option");
    opt.value=c.name;
    opt.textContent=c.name;
    charSelect.appendChild(opt);
  });
}
updateCharSelect();

// ===== ç‚¹å‡»æ¸²æŸ“ =====
document.getElementById("renderBtn").addEventListener("click",()=>{
  const selectedName=charSelect.value;
  const charObj=allChars.chars.find(c=>c.name===selectedName);
  if(!charObj) return alert("å­—ç¬¦ä¸å­˜åœ¨ï¼");
  renderChar(charObj.strokes, canvas.width, canvas.height);
});

// ===== æ·»åŠ æ–°å­—ç¬¦ =====
document.getElementById("addBtn").addEventListener("click",()=>{
  const name=document.getElementById("charName").value.trim();
  if(!name) return alert("è¯·è¾“å…¥å­—ç¬¦åç§°ï¼");
  const existing=allChars.chars.find(c=>c.name===name);
  if(existing) return alert("åç§°å·²å­˜åœ¨ï¼");
  // ç¤ºä¾‹ï¼šç©ºç¬”ç”»æ•°ç»„ï¼Œä¹‹åå¯ä»¥ç»˜åˆ¶
  const newChar={ name: name, strokes: [] };
  allChars.chars.push(newChar);
  localStorage.setItem("stargate_chars", JSON.stringify(allChars));
  updateCharSelect();
  alert("âœ… æ–°å­—ç¬¦æ·»åŠ æˆåŠŸï¼");
});

// ===== å¯¼å…¥ JSON =====
document.getElementById("importFile").addEventListener("change", function(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    const imported = JSON.parse(evt.target.result);
    allChars.chars = [...allChars.chars, ...imported.chars];
    localStorage.setItem("stargate_chars", JSON.stringify(allChars));
    updateCharSelect();
    alert("âœ… å¯¼å…¥æˆåŠŸï¼");
  }
  reader.readAsText(file);
});

// ===== å¯¼å‡ºåˆ°æœ¬åœ° =====
document.getElementById("exportBtn").addEventListener("click", function(){
  const jsonData = JSON.stringify(allChars, null, 2);
  const blob = new Blob([jsonData], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download="stargate_chars.json";
  a.click();
});

// ===== ä¸Šä¼ åˆ° GitHub =====
document.getElementById("uploadBtn").addEventListener("click", async function(){
  const jsonData = JSON.stringify(allChars, null, 2);
  const fileName = "stargate_chars.json";
  const repoOwner = 'zhou-yihui';
  const repoName = 'Dalianglanguage';
  const uploadPath = 'data/' + fileName;
  try{
    // é€šè¿‡ Android æ³¨å…¥æˆ– Node ç¯å¢ƒè·å– token
    const githubToken = window.AndroidToken?.getToken?.() || "";
    if(!githubToken) return alert("âŒ æœªæä¾› GitHub Tokenï¼");
    const checkResp = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/contents/${uploadPath}`, {
      headers: { Authorization: `token ${githubToken}` }
    });
    let sha = null;
    if(checkResp.ok){
      const existing = await checkResp.json();
      sha = existing.sha;
    }
    const uploadResp = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/contents/${uploadPath}`, {
      method:'PUT',
      headers:{
        Authorization:`token ${githubToken}`,
        'Content-Type':'application/json'
      },
      body: JSON.stringify({
        message:'Auto upload from Daliang IME system',
        content: btoa(unescape(encodeURIComponent(jsonData))),
        sha: sha || undefined
      })
    });
    if(uploadResp.ok) alert("âœ… ä¸Šä¼ æˆåŠŸï¼");
    else alert("âš ï¸ ä¸Šä¼ å¤±è´¥ï¼š" + uploadResp.status);
  }catch(err){
    console.error(err);
    alert("âŒ å‡ºé”™ï¼š" + err.message);
  }
});
</script>
</body>
</html>
